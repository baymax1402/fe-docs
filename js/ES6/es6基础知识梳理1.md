# ES6新特性

- 解决原有语法上的不足  let const的块级作用域
- 对原有语法进行增强   比如解构、展开、参数默认值、模板字符串
- 全新对象、方法、功能  promise、proxy、object的assign、is
- 全新的数据类型和数据结构   symbol、map、set



## 1.解决原有语法不足

### 1.1let、const、var的区别

- 和var的区别

| 声明方式 | 变量提升 | 作用域 | 初始值 | 重复定义 |
| -------- | -------- | ------ | ------ | -------- |
| Var      | 是       | 函数级 | 不需要 | 允许     |
| Let      | 否       | 块级   | 不需要 | 不允许   |
| Const    | 否       | 块级   | 必需   | 不允许   |

- Let、const声明的变量，在for、if中会形成块级作用域，块级作用域内的变量不能被作用域外部使用
- Let、const声明变量不会有声明提升，在变量声明之前使用运行时会报错
- 块级作用域声明变量，会出现”暂时性死区“, 声明前使用变量，将会报错
- const声明的是一个常量，声明必需初始化
- 如果const声明的是基本类型常量，初始化之后不能修改；引用类型的常量，可以修改其成员变量



**临时性死区:** 在当前的执行上下文中，会进行变量提升，但未初始化，所以在上下文执行阶段，执行代码如果还没有执行到变量赋值，引用此变量就会报错，此变量并未初始化





## 2.对原有语法增强

### 2.1rest参数&函数形参默认值

用途：获取函数的多余参数，不需要使用arguments对象了

用法：1）搭配的变量是一个数组，该变量将多余的参数放入数组中

​			2）rest参数之后不能有其他参数

​            3）函数的length属性，不包括rest参数

​            4）箭头函数不存在arguments, 可以用rest参数代替



浅拷贝：不复制继承的属性或类的属性，但是它会复制ES6的Symbols属性

### 2.2字符串扩展方法

Includes---是否包含   startsWith---是否以。。。开始  endsWith ---是否以。。。结束 



### 2.3解构赋值-快速提取数组/对象中的元素

#### 数组解构

- 根据索引单独解构
- 解构时可以给变量设置默认值
- ...变量名 解构剩余参数到新数组，只能用一次

#### 对象解构

- 根据key单独或多个解构
- 给解构出来的变量重命名
- 给解构变量设置默认值



### 2.4模板字符串

用法：用``将字符串包裹起来

功能：可以换行、插值、使用标签函数进行字符串操作



### 2.5数组扩展方法

#### 2.5.1  ...arr  、扩展运算符的应用

将某些数据结构转为数组

简单实现数组复制



#### 2.5.2  构造函数新增的方法

Array.from() 将两类对象转为真正的数组：类似数组的对象和可遍历的对象

Array.of() 用于将一组值转换为数组

#### 2.5.3实例对象新增的方法

copyWithin()

Find() findIndex()

Fill()

Entries() keys() values()

Includes()

Flat()  默认只会拉平一层

flatMap() 传入函数对数组进行处理再拉平

#### 2.5.4 排序稳定性

Sort()

### 2.6   函数的扩展

#### 2.6.1 参数

允许为函数参数设置默认值

- 函数形参是默认声明的， 不能用let const 再次声明
- 参数默认值可以与解构赋值的默认值结合起来使用
- 参数默认值应该是尾参数， 如果不是非尾部参数设置默认值，实际上这个参数是没法省略的

#### 2.6.2 属性

**函数的length属性**

- Length 返回没有指定默认值的参数个数
- rest参数也不会计入length属性
- 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了

**name属性**

返回该函数的函数名

- 如果将一个具名函数赋值给一个变量，则name属性都返回这个具名函数原本的名字
- Function构造函数返回的函数实例，name属性值为anonymous
- bind返回的函数，name属性值会加上bound前缀

#### 2.6.3 作用域

#### 2.6.4 严格模式

只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

#### 2.6.5箭头函数

##### 什么是箭头函数

ES6中允许使用箭头=>来定义箭头函数

相较普通函数语法简洁，省去了function关键字

##### 与普通函数的区别

- 语法更加简洁、清晰

- 箭头函数不会创建自己的this

  箭头函数没有自己的this, 它会捕获自己在定义时所处的外层执行环境的this, 并继承这个this值。所以箭头函数中this的指向在它被定义时已经确定了，之后永远不会改变

- 箭头函数继承而来的this指向永远不变

- call/apply/bind无法改变箭头函数中this的指向

- 箭头函数不能作为构造函数使用

- 箭头函数没有自己的arguments

  在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值

  箭头函数没有原型prototype

- 箭头函数不能用作generator函数，不能使用yield关键字

##### 好处和优势

- 简化了函数的写法
- 没有this机制，this继承自上一个函数的上下文，如果上一层没有函数，则指向window
- 作为异步回调函数时，可解决this指向问题



### 2.7对象新增扩展

#### 2.7.1 属性简写

- 同名属性可以省略key:value形式，直接key

​      当对象键名与对应值名可以相等时  可以简写

```
const baz = {foo: foo}
等同于
const baz = {foo}

方法也可以简写
const o = {
	method() {
	
	}
}
ps: 简写的对象方法不能用作构造函数，否则会报错
new obj.f()  //报错

等同于
const o = {
	method: function() {
	
	}
}

函数内作为返回值，变得方便
function getPoint() {
	const x = 1;
	const y = 10;
	return {x, y}  //{x: 1, y： 10}
}
```



#### 2.7.2 属性名表达式

- 允许字面量定义对象时，将表达式放在括号内

```
let lastWord = 'last word'
const a = {
	'first word': 'hello',
	[lastWord]: 'world'
}
```

- 表达式还可以用于定义方法名

```
let obj = {
	['h' + 'ello']() {
		return 'hi'
	}
}
obj.hello()
```

   注意： 属性名表达式与简洁表示法，不能同时使用，会报错

​				属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object object]



#### 2.7.3 super关键字

指向当前对象的原型对象

#### 2.7.4 扩展运算符的应用

解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面

解构赋值是浅拷贝

对象的扩展运算符等同于使用Object.assign()方法

#### 2.7.5 属性的遍历

- for in  循环遍历对象自身的和继承的可枚举属性  (不包含Symbol属性)
- Object.keys(obj)  返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）的键名
- Object.getOwnPropertyNames(obj) 返回一个数组，包括对象自身的所有属性（不含Symbol属性， 但包括不可枚举属性）的键名
- Object.getOwnPropertySymbols(obj) 返回一个数组，包含对象自身的所有Symbol属性的键名
- Reflect.ownKeys(obj)  返回一个数组，包括对象自身的（不含继承的）所有键名

属性遍历规则：

- 首先遍历所有数值键，按照数值升序排列
- 其次遍历所有字符串键，按照加入时间升序排列
- 最后遍历所有Symbol键，按照加入时间升序排列

#### 2.7.6   对象新增的方法

- Object.is()

​       严格判断两个值是否相等，与===行为基本一致，不同之处有两个：

​	

```
+0 === -0  //true
NaN === NaN //false

Object.is(+0, -0) //false
Object.is(NaN, NaN) //true
```

- Object.assign(target, source1, source2)

  用于对象合并，将源对象source的所有可枚举属性，复制到目标对象target

 Ps:浅拷贝

- Object.getOwnPropertyDescriptors()

 返回指定对象所有自身属性（非继承属性）的描述对象

{ foo: {

​	value:

​	writable:

​    enumerable

   Configurable

}

}

- Object.setPrototypeOf(object, prototype), Object.getPrototypeOf()

  设置、读取一个对象的原型对象

- Object.keys(), Object.values(), Object.entries()

   返回一个对象自身的（不含继承的）所有可遍历属性的键名数组、键对应值的数组，键值对的数组

- Object.fromEntries()

  将一个键值对数组转为对象




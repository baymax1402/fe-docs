# 1.解密HTTP/2与HTTP/3 的新特性

HTTP/2 相比于 HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。

虽然 HTTP/2 提高了网页的性能，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。**想阅读更多优质文章请猛戳[GitHub博客](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fljianshu%2FBlog)**

## 一、HTTP/1.1发明以来发生了哪些变化？

如果仔细观察打开那些最流行的网站首页所需要下载的资源的话，会发现一个非常明显的趋势。 近年来加载网站首页需要的下载的数据量在逐渐增加，并已经超过了2100K。但在这里我们更应该关心的是：平均每个页面为了完成显示与渲染所需要下载的资源数已经超过了100个。

正如下图所示，从2011年以来,传输数据大小与平均请求资源数量不断持续增长，并没有减缓的迹象。该图表中绿色直线展示了传输数据大小的增长，红色直线展示了平均请求资源数量的增长。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/8/16dac0abe398815f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

HTTP/1.1自从1997年发布以来，我们已经使用HTTP/1.x 相当长一段时间了，但是随着近十年互联网的爆炸式发展，从当初网页内容以文本为主,到现在以富媒体（如图片、声音、视频）为主,而且对页面内容实时性高要求的应用越来越多(比如聊天、视频直播),于是当时协议规定的某些特性，已经无法满足现代网络的需求了。

## 二、HTTP/1.1的缺陷

### 1.高延迟--带来页面加载速度的降低

虽然近几年来网络带宽增长非常快，然而我们却并没有看到网络延迟有对应程度的降低。**网络延迟问题主要由于队头阻塞(Head-Of-Line Blocking),导致带宽无法被充分利用**。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/9/16dac2ad1e9cb617~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对队头阻塞,人们尝试过以下办法来解决:

- 将同一页面的资源分散到不同域名下，提升连接上限。 **Chrome有个机制，对于同一个域名，默认允许同时建立 6 个 TCP持久连接**，使用持久连接时，虽然能公用一个TCP管道，**但是在一个管道中同一时刻只能处理一个请求**，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。
- Spriting合并多张小图为一张大图,再用JavaScript或者CSS将小图重新“切割”出来的技术。
- 内联(Inlining)是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。

```
.icon1 {
    background: url(data:image/png;base64,<data>) no-repeat;
  }
.icon2 {
    background: url(data:image/png;base64,<data>) no-repeat;
  }
复制代码
```

- 拼接(Concatenation)将多个体积较小的JavaScript使用webpack等工具打包成1个体积更大的JavaScript文件,但如果其中1个文件的改动就会导致大量数据被重新下载多个文件。

### 2.无状态特性--带来的巨大HTTP头部

由于报文Header一般会携带"User Agent""Cookie""Accept""Server"等许多固定的头字段（如下图），多达几百字节甚至上千字节，但Body却经常只有几十字节（比如GET请求、 204/301/304响应），成了不折不扣的“大头儿子”。Header里携带的内容过大，在一定程度上增加了传输的成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/11/16db88a2046de4bd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### 3.明文传输--带来的不安全性

HTTP/1.1在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。

你有没有听说过"免费WiFi陷阱”之类的新闻呢？ 黑客就是利用了HTTP明文传输的缺点，在公共场所架设一个WiFi热点开始“钓鱼”，诱骗网民上网。一旦你连上了这个WiFi热点，所有的流量都会被截获保存，里面如果有银行卡号、网站密码等敏感信息的话那就危险了，黑客拿到了这些数据就可以冒充你为所欲为。

### 4.不支持服务器推送消息

## 三、SPDY 协议与 HTTP/2 简介

### 1.SPDY 协议

上面我们提到,由于HTTP/1.x的缺陷，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到2009年，谷歌公开了自行研发的 SPDY 协议，主要解决HTTP/1.1效率不高的问题。谷歌推出SPDY，才算是正式改造HTTP协议本身。降低延迟，压缩header等等，SPDY的实践证明了这些优化的效果，也最终带来HTTP/2的诞生。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/9/16db12f4a7f9db84~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

**HTTP/1.1有两个主要的缺点：安全不足和性能不高**，由于背负着 HTTP/1.x 庞大的历史包袱,所以协议的修改,兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产。如上图所示, SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。

SPDY 协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。

### 2.HTTP/2 简介

2015年，HTTP/2 发布。HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写，HTTP方法/状态码/语义都与HTTP/1.x一样。**HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）**。从目前的情况来看，国内外一些排名靠前的站点基本都实现了HTTP/2的部署，使用HTTP/2能带来20%~60%的效率提升。

HTTP/2由两个规范（Specification）组成：

1. Hypertext Transfer Protocol version 2 - RFC7540
2. HPACK - Header Compression for HTTP/2 - RFC7541

## 四、HTTP/2 新特性

### 1.二进制传输

**HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩**。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。 **HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码**。

它把TCP协议的部分特性挪到了应用层，把原来的"Header+Body"的消息"打散"为数个小片的二进制"帧"(Frame),用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。HTP/2数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/28/16934b619431d975~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。**多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装**。

### 2.Header 压缩

HTTP/2并没有使用传统的压缩算法，而是开发了专门的"HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。

具体来说:

- 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；
- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
- 每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值

例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销 ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/28/16934a8dc2cde720~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### 3.多路复用

在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。

大家可以通过 [该链接](https://link.juejin.cn?target=https%3A%2F%2Fhttp2.akamai.com%2Fdemo) 直观感受下 HTTP/2 比 HTTP/1 到底快了多少。 ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/14/168ec90846f566fb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp) 在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中,

- 同域名下所有通信都在单个连接上完成。
- 单个连接可以承载任意数量的双向数据流。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

这一特性，使性能有了极大提升：

- 同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。
- 并行交错地发送多个请求/响应，请求/响应之间互不影响。
- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692fa29e41348f7~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp) 如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。

### 4.Server Push

HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）

例如下图所示,服务端主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/28/16934a8dd0ad7485~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

另外需要补充的是,服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。

### 5.提高安全性

出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。

但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，**所以“事实上”的HTTP/2是加密的**。也就是说，互联网上通常所能见到的HTTP/2都是使用"https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2"表示加密的HTTP/2，“h2c”表示明文的HTTP/2。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/15/16dcd65b07b762b9~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

## 六、HTTP/3 新特性

### 1.HTTP/2 的缺点

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，**主要是底层支撑的 TCP 协议造成的**。HTTP/2的缺点主要有以下几点：

- TCP 以及 TCP+TLS建立连接的延时

HTTP/2使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，**这样就需要有两个握手延迟过程**：

①在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。

②进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT。

总之，在传输数据之前，我们需要花掉 3～4 个 RTT。

- TCP的队头阻塞并没有彻底解决

上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/15/16dd01ce6dc2315d~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

读到这里，可能就会有人考虑为什么不直接去修改 TCP 协议？其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。

### 2.HTTP/3简介

Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。 而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/15/16dcd72a656d904d~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。不过HTTP/3目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。

### 3.QUIC新功能

上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流"是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：

- 实现了类似TCP的流量控制、传输可靠性的功能。

虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。

- 实现了快速握手功能。

由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。**0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势**。

- 集成了TLS加密功能。

目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。

- 多路复用，彻底解决TCP中队头阻塞的问题

和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/15/16dd01e459dcc11b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

## 七、总结

- HTTP/1.1有两个主要的缺点：安全不足和性能不高。
- HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS"，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；
- QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议


参考链接：https://juejin.cn/post/6844903968380813325

# 2.说说WebSocket和HTTP的区别

## HTTP协议

HTTP是单向的，客户端发送请求，服务器发送响应。当客户端向服务器发送请求时，该请求以HTTP或HTTPS的形式发送，服务器在接收到请求后会将响应发送给客户端。

每个请求都与一个对应的响应相关联，在发送响应后客户端与服务器的连接会被关闭。每个HTTP或HTTPS请求每次都会新建与服务器的连接，并且在获得响应后，连接将自行终止。 HTTP是在TCP之上运行的无状态协议。

HTTP可以运行在任何可靠的面向连接的协议（例如TCP，SCTP）的上层。当客户端将HTTP请求发送到服务器时，客户端和服务器之间将打开TCP连接，并且在收到响应后，TCP连接将终止，每个HTTP请求都会建立单独的TCP连接到服务器，如果客户端向服务器发送10个请求，则会打开10个单独的HTTP连接。并在获得响应后关闭。

## WebSocket协议

WebSocket是双向的，在客户端与服务器通信的场景中使用的全双工协议，与HTTP不同，它以ws://或wss://开头。它是一个有状态协议，这意味着客户端和服务器之间的连接将保持活动状态，直到被客户端或服务器终止。在客户端和服务器中的任何一方关闭连接之后，连接将从两端终止。

以客户端与服务器通信为例，每当启动客户端和服务器之间的连接时，客户端与服务器进行握手随后创建一个新的连接，该连接将保持活动状态，直到被他们中的任何一方终止。建立连接并保持活动状态后，客户端和服务器将使用相同的连接通道进行通信，直到连接终止。

新建的连接被称为WebSocket。一旦通信链接建立和连接打开后，消息交换将以双向模式进行，客户端与服务器之间的连接会持续存在。如果其中任何一方（客户端服务器）宕掉或主动关闭连接，则双方均将关闭连接。WebSocket的工作方式与HTTP的工作方式略有不同，状态代码101表示WebSocket中的交换协议。

## 应用场景

### WebSocket

即时Web应用程序
游戏应用程序
聊天应用程序

### HTTP

要获取旧数据，或者只想获取一次数据供应用程序使用

原文链接：https://blog.csdn.net/weixin_49078296/article/details/124652923



# 3.你知道哪些应用层协议

应用层协议有：1、域名系统DNS协议、FTP文件传输协议、、telnet远程终端协议、HTTP超文本传送协议、SMTP电子邮件协议、POP3邮件读取协议、Telnet远程登录协议、SNMP简单网络管理协议等。 

应用层协议(application layer protocol)定义了运行在不同端系统上的应用程序进程如何相互传递报文。


1、DNS：域名系统DNS是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。

现在顶级域名TLD分为三大类：国家顶级域名nTLD；通用顶级域名gTLD;基础结构域名

域名服务器分为四种类型：根域名服务器；顶级域名服务器；本地域名服务器；权限域名服务器。

2、FTP：文件传输协议FTP是因特网上使用得最广泛的文件传送协议。FTP提供交互式的访问，允许客户指明文件类型与格式，并允许文件具有存取权限。FTP其于TCP。

3、telnet远程终端协议：telnet是一个简单的远程终端协议，它也是因特网的正式标准。又称为终端仿真协议。

4、HTTP：超文本传送协议，是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。http使用面向连接的TCP作为运输层协议，保证了数据的可靠传输。

5、电子邮件协议SMTP：即简单邮件传送协议。SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。SMTP通信的三个阶段：建立连接、邮件传送、连接释放。

6、POP3：邮件读取协议，POP3(Post Office Protocol 3)协议通常被用来接收电子邮件。

7、远程登录协议(Telnet)：用于实现远程登录功能。

8、SNMP：简单网络管理协议。由三部分组成：SNMP本身、管理信息结构SMI和管理信息MIB。SNMP定义了管理站和代理之间所交换的分组格式。SMI定义了命名对象类型的通用规则，以及把对象和对象的值进行编码。MIB在被管理的实体中创建了命名对象，并规定类型。
————————————————
参考链接：https://blog.csdn.net/u011149152/article/details/122718757



# 4.TCP是怎么判断丢包的？

TCP 是一种提供可靠性交付的协议。 也就是说，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。 但是在网络中相连两端之间的介质，是复杂的，并不确保数据的可靠性交付，那么 TCP 是怎么样解决问题的？ TCP 是通过下面几个特性保证数据传输的可靠性：

- **序列号和确认应答信号**
- **超时重发控制**
- **连接管理**
- **滑动窗口控制**
- **流量控制**
- **拥塞控制**

由于篇幅有限，这个TCP协议可靠性的专题我分为上下两篇来写，这一篇先讨论前四个可靠性机制，剩下的流量控制和拥塞控制，会写到另外一篇文章：[TCP协议可靠性是如何保证之 流量控制和拥塞控制](https://juejin.cn/post/6844904073611722760) 关于TCP协议的文章还有几篇，大家也可以看看：

- [一文彻底搞懂 TCP三次握手、四次挥手过程及原理](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIYopLBVowY8eWDZ0XOQ8IQ)
- [面试官：说说UDP和TCP的区别及应用场景](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fbnlm2b7ADgZqMCEpqEcz6A)
- [TCP协议可靠性是如何保证之 流量控制和拥塞控制](https://juejin.cn/post/6844904073611722760)

### 通过序列号和确认应答信号提高可靠性

如下图，在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做**确认应答（ACK）**。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。

![TCP的ACK确认](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531a9eacac54~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



但是，如果在一定时间内发送端都没有得到确认应答ACK，发送端就会认为数据丢失，并进行**数据重发**。所以，即使产生了丢包，TCP仍然能保证数据能够到达对端，实现可靠的传输。 发送端没有得到确认应答ACK的原因，主要分两种情况：

- \1. 发送端发送的数据丢包

  ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531a9ebacbc8~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

  上图中的主机A发出数据后因为网络拥堵等原因导致了丢包，数据无法达到主机B，此时，主机A如果在一个特定的时间间隔内都没收到主机B的ACK，则会将数据进行重发

- \2.  接收端发送的确认应答ACK丢包或延迟

  ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531aa1d12c7b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

  这个图中主机A的数据正常发送到主机B，但由于网络堵塞等原因，主机B的ACK没有达到主机A。主机A在一定时间间隔内始终没收到ACK，则会重发这个数据。 此时，主机B收到数据后就会再次发送ACK，但是由于主机B已经接收过1-1000的数据，所以当再有相同数据达到它时就会放弃这个数据。

此外，也有可能因为一些其他原因导致ACK延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。

虽然目标主机通过重发数据可以提供可靠的传输，但是对于目标主机来说，反复收到相同的数据可能会是一个”灾难“，既浪费网络资源，还要耗资源对它处理。 所以，我们**需要一种机制来识别是否已经接收到了这个数据包、又能够判断数据包是否需要接收。**

目标主机反复收到相同数据是不可取的，为了保持数据的一致性，目标主机必须扔掉重复的数据包，那么怎么判断该数据包是已经重复收取过呢？ 为此我们引入了**序列号**。

序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。**通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。**

所以，通过序列号，上面说的**确认应答ACK处理， 重发控制，重复控制**都能实现了。

### 超时重发如何确定呢？

- **重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔**。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。 最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。

- TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间（RTT Round Trip Time）及其偏差（RTT波动的时间，也叫抖动）。**将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。**

- 重发超时既要考虑RTT往返时间，又要考虑网络抖动的偏差，如下图所示，网络网络环境不同可能会造成RTT大幅度摆动，TCP/IP的目的就是即使在这种环境下也能进行控制，不浪费网络流量。

  ![RTT](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531aa1effb32~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

  

- 在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。

- 数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。

- 此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。

### 连接管理

TCP是**面向连接**的通信协议，面向连接是指在数据通信之前先做好通信两端之间的准备工作。 因此，在数据通信之前，会通过TCP首部发送一个`SYN`包作为建立连接和等待确认应答，如果对端发来确认应答ACK，则认为可以进行通信，否则如果对端没有发送正确的ACK应答，那么就不会通信。 另外通信完毕需要发送`FIN`包来关闭连接

这就是我们常常说的 **三次握手建立连接 和四次挥手关闭连接** 我之前也写了一篇  [一文彻底搞懂 TCP三次握手、四次挥手过程及原理](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIYopLBVowY8eWDZ0XOQ8IQ)，大家有兴趣可以去看看，了解TCP连接时如何建立和关闭的

### TCP是以段为单位进行数据包的发送的

在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为**“最大消息长度”（MSS，Max Segment Size）**，也就是一个段。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。

TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS  为单位。

MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS  选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。

![window](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531aa227a28a~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

上图的是Tcpdump抓包的信息，在三次握手建立连接时，大家都交换了对方的MSS，目的是告诉对方，我能适应每次TCP数据传输单位最大是多少，后面通信双方就会按照这个MSS大小作为发送单位发送数据，以上图为例，TCP每次传输最多不会超过65495字节



### 利用滑动窗口控制提高速度

上面说了，TCP 以1个段为单位，如果每发送一个段进行一次确认应答，才能进行下一次通信，那这样的传输方式有一个缺点，就是包的往返时间（RTT）越长通信性能就越低。如下图：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531aa730f8fd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

这种方式有点类似于数据库不能并发请求，只能一个挨一个的处理，自然这样的效率肯定是比并发低的



为解决这个问题，TCP 引入了**窗口**这个概念。**确认应答不是以每个分段来确认，而是以更大的单位进行确认**，转发时间将会被大幅地缩短。也就是说，**发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送**。如下图所示：

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531ad20cbfca~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

如上图，我们假设窗口大小是4000字节，主机A可以一口气发送把4000字节的序列号发送完毕。这个跟前面每个段接收ACK后才能继续发送新一个段的情况相比，即使RTT变长也不会影响网络的吞吐量。 **窗口大小就是指无需等待确认应答ACK而继续发送数据的最大值**。 这种窗口机制实现了使用了大量的缓冲区（Buffer，指的是计算机存储收发数据的的内存空间），通过对多个段同时进行确认应答的功能。



滑动窗口示意图如下：

![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531ad98f8962~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



上面这个图一个段为1000字节，滑动窗口是4个段，在①的状态下，如果收到一个序列号为2000的ACK，那么2001 之前的数据就没必要重发了，这部分的数据可以被过滤掉，滑动窗口成为③的样子。 对于滑动窗口有以下几点特点：

- 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，**在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传**。为此，发送端主机需要**设置缓存保留这些待被重传的数据，直到收到他们的确认应答**。
- 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。
- 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。**这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制**。

### 滑动窗口控制与重发控制

在使用了窗口控制中，如果出现了丢包怎么办呢？这里我们还是分两种情况分析：

- **1.确认应答ACK未能正确返回的情况** 在这种情况下，数据是已经被对端主机成功接收了的，是不需要进行重新发送的。 然而，如果在没有使用窗口控制的前提下，没有收到确认应答包的数据包都会被重发。 但是，在使用了窗口控制以后，就如下图所示，某些应答包即使丢失了也无需重发，这也提高了传输效率。

  ![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/1708531adbd77315~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

  如上图所示，一个段大小为1000字节，一个窗口大小为6000个字节的情况，主机A连续发送了6000序列号的数据，中间的主机B对1001的ACK丢失了，但是后面的2001的ACK正常返回了，说明前2000的序列号的数据都正常读取了，那么即使1001的ACK丢失也不需要进行数据重发！

  所以在窗口控制的机制下，前面的ACK丢失，也能通过下一个ACK进行确认，提高了不少效率。

  

- **2.某个报文丢失的情况** 如果当接收端主机接收到一个自己应该接收的序列号之外的数据包时，它会一直对当前接收到的数据包返回确认应答包。



![image](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/170852f0e03b1b57~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

如上图所示，主机A的1001-2000序列号的报文丢失了，它会一直收到来自主机B的一个1001的ACK，这个ACK就像在跟主机A提醒  “我想接收从1001开始的数据”。当主机A连续收到这个1001的确认应答ACK **3次**后，就会认为数据丢失了，需要重发。



在滑动窗口比较大的情况下，同一个序列号的确认应答将会被重复不断地返回。**而发送端主机如果 连续 3 次 接收到同一个确认应答包，就会将其对应的数据重发，这种机制比之前提到的“超时重发”更加高效，所以被称之为“高速重发控制”**

### 总结

TCP协议在实现传输可靠性上面做了很多：

- 通过**序列号和确认应答信号**确保了数据不会重复发送和重复接收。
- 同时通过**超时重发控制**保证即使数据包在传输过程中丢失，也能重发保持数据完整。
- 通过三次握手，四次挥手建立和关闭连接的**连接管理**保证了端对端的通信可靠性。
- TCP还使用了**滑动窗口控制**提高了数据传输效率
- TCP的流量控制和拥塞控制可以查看我的另外一篇文章：：[TCP协议可靠性是如何保证之 流量控制和拥塞控制](https://juejin.cn/post/6844904073611722760)


作者：公众号_码农富哥
链接：https://juejin.cn/post/6844904072181465095
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。















# 5.TCP和HTTP请求之间有什么关系？

> 1. 网页中的图片资源为什么分放在不同的域名下？
> 2. 浏览器与服务器建立一个TCP连接后，是否会在完成一个http请求后断开？什么条件下会断开？
> 3. 一个TCP连接可以同时发送几个HTTP请求？
> 4. 浏览器http请求的并发性是如何体现的？并发请求的数量有没有限制？

**第一个问题：**

> 网页中的图片资源为什么分放在不同的域名下?

浏览器对并发请求的数目限制是针对域名的，即针对同一域名（包括二级域名）在同一时间支持的并发请求数量的限制。如果请求数目超出限制，则会阻塞。因此，网站中对一些静态资源，使用不同的一级域名，可以提升浏览器并行请求的数目，加速界面资源的获取速度。

**第二个问题**

> 浏览器与服务器建立一个TCP连接后，是否会在完成一个http请求后断开？什么条件下会断开？

在`HTTP/1.0`中，一个http请求收到服务器响应后，会断开对应的TCP连接。这样每次请求，都需要重新建立TCP连接，这样一直重复建立和断开的过程，比较耗时。所以为了充分利用TCP连接，可以设置头字段`Connection: keep-alive`，这样http请求完成后，就不会断开当前的TCP连接，后续的http请求可以使用当前TCP连接进行通信。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca78fb3764e19b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



第一次访问有初始化连接和SSL开销



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca78fb3769c3a2~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



初始化连接和SSL开销消失了，说明使用的是同一个TCP连接。

`HTTP/1.1`将`Connection`写入了标准，默认值为`keep-alive`。除非强制设置为`Connection: close`，才会在请求后断开TCP连接。

所以这一题的答案就是：默认情况下建立的TCP连接不会断开，只有在请求头中设置`Connection: close`才会在请求后关闭TCP连接。

**第三个问题**

> 一个TCP连接可以同时发送几个HTTP请求？

`HTTP/1.1`中，单个TCP连接，在同一时间只能处理一个http请求，虽然存在Pipelining技术支持多个请求同时发送，但由于实践中存在很多问题无法解决，所以浏览器默认是关闭，所以可以认为是不支持同时多个请求。

`HTTP2`提供了多路传输功能，多个http请求，可以同时在同一个TCP连接中进行传输。

**第四个问题**

> 浏览器http请求的并发性是如何体现的？并发请求的数量有没有限制？

页面资源请求时，浏览器会同时和服务器建立多个TCP连接，在同一个TCP连接上顺序处理多个HTTP请求。所以浏览器的并发性就体现在可以建立多个TCP连接，来支持多个http同时请求。

Chrome浏览器最多允许对同一个域名Host建立6个TCP连接，不同的浏览器有所区别。

### 补充

如果图片都是HTTPS的连接，并且在同一域名下，浏览器会先和服务器协商使用`HTTP2`的`Multiplexing`功能进行多路传输，不过未必所有的挂在这个域名下的资源都会使用同一个TCP连接。如果用不了HTTPS或者HTTP2（HTTP2是在HTTPS上实现的），那么浏览器会就在同一个host建立多个TCP连接，每一个TCP连接进行顺序请求资源。


原文链接：https://juejin.cn/post/6844903918820917255

# 6.从输入URL到页面呈现发生了什么？

## 前言

> 从输入URL到页面显示不仅仅是一道经典的面试题，这个知识点中涉及到了非常广泛的知识点，因此面试官可以通过这个问题有点到面的向候选人发起提问，因此这个面试题被频繁的问到，所以下面让我们来好好看看这个题目该如何回答。

## 阶段一：用户输入阶段

> 用户在地址栏输入内容之后，浏览器会首先判断用户输入的是合法的URL还是搜索内容，如果是搜索内容就合成URL，如果是合法的URL就开始进行加载。

## 阶段二：发起URL请求阶段

> 发起URL请求阶段主要包括以下步骤：

1. 构建请求行：浏览器进程首先会构建请求行信息，然后通过进程间通信IPC将URL请求发送给网络进程。
2. 查找缓存：网络进程获取到URL之后，会先去本地缓存中查找是否有缓存资源，如果有则直接将缓存资源返回给浏览器进程，否则进入网络请求阶段。
3. DNS解析：网络进程请求首先会从DNS数据缓存服务器中查找是否缓存过当前域名的信息，有则直接返回，否则，会进行DNS解析域名对应的IP和端口号。
4. 等待TCP队列：chrome有个机制，同一个域名同时最多只能建立6个TCP连接，如果超过这个数量的连接必须要进入排队等待状态。
5. 建立TCP连接：通过TCP三次握手与服务器建立连接，然后进行数据传输。
6. 发起HTTP请求：浏览器首先会向服务器发送请求行，请求行中包含了请求方法、请求URI和HTTP版本，还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核、请求域名、Cookie等信息。
7. 服务器处理请求：服务器首先返回相应行，包括协议版本和状态码，然后会返回响应头包含返回的数据类型，服务器要在客户端保存的Cookie等。
8. 断开TCP连接：数据传输完成后，通过四次挥手来断开连接。

## 阶段三：准备渲染进程阶段

1. 网络进程将获取的数据进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器去下载，如果是text/html类型，就通知浏览器进程获取到的是HTML，准备渲染进程。
2. 一般情况下浏览器的一个tab页面对应一个渲染进程，如果从当前页面打开的新页面并且属于同一站点，这种情况会复用渲染进程，其他情况则需要创建新的渲染进程。

## 阶段四：提交文档阶段

1. 渲染进程准备好之后，浏览器会发出提交文档的消息给渲染进程，渲染进程收到消息后，会和网络进程建立数据传输的管道，文档数据传输完成后，渲染进程会返回确认提交的消息给浏览器进程。
2. 浏览器收到确认提交的消息后，会更新浏览器的页面状态，包括了安全状态，地址栏的URL，前进后退的历史状态，并更新web页面为空白。

## 阶段五：页面渲染阶段

1. 文档提交之后，渲染进程将开始页面解析并加载子资源。
2. 构建DOM树：HTML经过解析后输出的是一个以document为顶层节点的树状结构的DOM。
3. 样式计算：将从link标签引入的外部样式，style标签里的样式和元素身上的样式转换成浏览器能够理解的样式表，然后将样式表中的属性值进行标准化，例如color:red转换为color的rgb形式，然后根据CSS的继承和层叠规则计算出DOM树种每个节点的具体样式。
4. 布局阶段：会生成一棵只包含可见元素的布局树，然后根据布局树的每个节点计算出其具体位置和大小。
5. 分层：对页面种的复杂效果例如3D转换，页面滚动或者z轴排序等生成图层树。
6. 绘制：为每个图层生成绘制列表，并将其提交到合成线程中。
7. 光栅化：优先选择可视窗口内的图块来生成位图数据。
8. 合成：所有图块都被光栅话之后开始显示页面。

## 问题汇总

### RQ1：浏览器解析HTML过程

> 针对这个问题，我们可以从阶段五：页面渲染阶段来回答。

### RQ2：强缓存和协商缓存发生在那个阶段？

> 强缓存和协商缓存发生在发起URL请求阶段，在这个阶段构建请求行之后会查找缓存。

### RQ3：DNS解析中端口需要DNS解析吗？

> 不需要，因为HTTP默认的是80端口，HTTPS默认的是443端口，如果要指定端口可以直接在URL里面添加。

### RQ4：哪些阶段可以优化？

1. 优化DNS查询：DNS预解析
2. 优化TCP连接：可以通过请求头keep-alive来优化。
3. 优化HTTP响应报文：通过CDN和Gzip压缩。

参考链接：https://juejin.cn/post/7066582950967509028

# 7.301、302、303\307\308这些状态码有什么区别？



# 8.HTTP状态码

